//Copyright (c) 2022 user1687569

// 派生类与基类之间的一些特殊关系
1. 派生类对象可以使用基类的方法，条件是方法不是私有的
2. 基类指针可以在不进行显式类型转换的情况下指向派生类对象
3. 基类引用可以在不进行显式类型转换的情况下引用派生类对象
4. 然而，基类指针或引用只能用于调用基类方法


// 静态联编 和 动态联编
编译器对(非虚方法)使用静态联编
编译器对(虚方法)使用动态联编


C++规定了虚函数的行为，但将实现方法留给了编译器作者。
通常，编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。
隐藏成员中保存了一个指向函数地址数组的指针。
这种数组称为虚函数表(virtual function table, vtbl)
虚函数表中存储了为类对象进行声明的虚函数的地址。
例如，基类对象包含一个指针，该指针指向基类中所有虚函数的地址表。
派生类对象将包含一个指向独立地址表的指针。
如果派生类提供虚函数的新定义，该虚函数表将保存新函数的地址；
如果派生类中没有重新定义虚函数，该vbtl将报讯函数原始版本的地址。
如果派生类定义了新的虚函数，则该函数的地址也将被添加到vtbl中。
无论类中包含的虚函数是1个还是10个，都只需要在对象中添加1个地址成员，只是表的大小不同而已。


// 关于虚方法的一些其他知识
1. 构造函数: 构造函数不能是虚函数
2. 析构函数: 析构函数应当是虚函数，除非类不用做基类
    提示：通常应给基类提供一个虚析构函数，即使它并不需要析构函数
3. 友元：友元不能是虚函数，因为友元不是类成员，而只有成员才能是虚函数
4. 没有重新定义：如果派生类没有重新定义函数，将使用该函数的基类版本
5. 重新定义将隐藏方法


// 虚方法：返回类型协变 covariance of return type
如果重新定义继承的方法，应确保与原来的原型完全相同，
但如果返回类型是基类引用或指针，则可以修改为指向派生类
的引用或指针，这种特性被称为返回类型协变。


// 虚方法
如果基类声明被重载了，则应在派生类中重新定义所有的基类版本


// protected
protected 与 private 的异同点？
相同点：在类外只能用公有类成员来访问protected部分中的类成员，与private一样
不同点：派生类可以直接访问基类中protected部分的类成员，而派生类无法直接访问基类中private部分的类成员


// ABC 抽象基类
ABC: Abstract base class
纯虚函数声明的结尾处为=0
当类声明中包含纯虚函数时，则不能创建该类的对象。
包含纯虚函数的类只用作基类。
要称为真正的ABC，必须至少包含一个纯虚函数。


默认的赋值运算符用于处理同类对象之间的赋值


一定要定义显式析构函数来释放类构造函数使用new分配的所有内存，
并完成类对象所需的任何特殊的清理工作。


使用一个参数就可以调用的构造函数定义了从参数类型到类类型的转换
在带一个参数的构造函数原型中使用explicit将禁止进行隐式转换，但仍允许显式转换


// 什么是不能被继承的
1. 构造函数是不能继承的
2. 析构函数也是不能继承的
3. 赋值运算符是不能继承的



// 1 派生类从基类那里继承了什么
派生类对象存储了基类的数据成员(派生类继承了基类的实现)
派生类对象可以使用基类的方法(派生类继承了基类的接口)


// 2 派生类不能从基类那里继承什么
不能继承构造函数、析构函数、赋值运算符和友元


// 3 
// ######
假设baseDMA::operator=()函数的返回类型为void,而不是baseDMA &, 
则仍可以使用单个赋值，但不能使用连锁赋值

如果返回类型为baseDMA, 而不是baseDMA &， 则该方法的执行速度将有所减慢，
这是因为返回语句需要复制对象。


// 4 创建和删除派生类对象时，构造函数和析构函数调用的顺序是怎样的？
创建派生类对象时，将首先调用基类的构造函数，再调用派生类的构造函数
删除派生类对象时，将首先调用派生类的析构函数，再调用基类的析构函数


// 5
如果派生类没有添加任何数据，它仍需要构造函数


// 6
如果基类和派生类定义了同名的方法， 当派生类对象调用该方法时，
被调用的时派生类定义的方法。


// 7
当派生类新增了需要使用new的数据成员，派生类应定义赋值运算符


// 8
可以将派生类对象的地址赋给基类指针
不可以将基类对象的地址赋给派生类指针


// 9
可以将派生类对象赋给基类对象
不可以将基类对象赋给派生类对象


// 10 假设定义了一个函数，它将基类对象的引用作为参数，
//    为什么该函数也可以将派生类对象作为参数？
因为基类对象的引用可以在不进行显式类型转换的情况下指向派生类对象


// 11 假设定义了一个函数，它将基类对象作为参数(即函数按值传递基类对象)。
//    为什么该函数也可以将派生类对象作为参数？
按值传递对象将调用复制构造函数。由于形参是基类对象，因此将调用基类的
复制构造函数。复制构造函数以基类引用为参数，该引用可以指向作为参数传递
的派生对象。最终结果是，将生成一个新的基类对象，其成员对应于派生对象的
基类部分。


// 12 为什么通常按引用传递对象比按值传递对象的效率更高？
按引用(而不是按值)传递对象，这样可以确保函数从虚函数受益。
另外，按引用(而不是按值)传递对象可以节省内存和时间，尤其对于
大型对象。按值传递对象的主要优点在于可以保护原始数据，但可以通过
将引用作为const类型传递，来达到同样的目的。


// 13
a. 常规非虚方法
ph->head()将被解释为 基类Corparation的 Corporation::head()方法

b. 虚方法
ph->head()将被解释为 派生类PulicCorparation的 PublicCorporation::head() 方法


// 14
首先，这种情况不符合 is-a模型，因此公有继承不适用
其次，House中的area()定义隐藏了area()的Kitchen版本，
因为这两个方法的特征标不同。








