//Copyright (c) 2022 user1687569

string类
#include <string>
string类实际上是模板具体化basic_string<char>的一个typedef,
同时省略了与内存管理相关的参数

string::npos定义为字符串的最大长度

string类的构造函数：
string(const char * s)
string(size_type n, char c)
string(const string & str)
string()
string(const char * s, size_type n)

template<class Iter>
string(Iter begin, Iter end)  将string对象初始化为区间[begin, end)内的字符

string(const string & str, string size_type pos = 0, size_type n = npos)

--------------------------------------
C++新增的构造方法
string(string && str) noexcept
类似于复制构造函数，导致新创建的string为str的副本
但与复制构造函数不同的是，它不保证将str视为const.
这种构造函数被称为移动构造函数(move constructor)
--------------------------------------


--------------------------------------
C++新增的构造方法
string(initializer_list<char>il)
该方法让你能够将列表初始化语法用于string类
--------------------------------------

--------------------------------------
对于C-风格字符串，有3种方式
char info[100];
std::cin >> info;
std::cin.getline(info, 100);
std::cin.get(info, 100);
--------------------------------------
--------------------------------------
对于string对象，有两种方式
string stuff;
std::cin >> stuff;
std::getline(std::cin, stuff);      // 自动匹配字符串长度, std::cin只是一个参数
--------------------------------------
两个版本的getline()都有一个可选参数，用于指定
使用哪个字符来确定输入的边界
std::cin.getline(info, 100, ':');   // read up to :, discard :
std::getline(stuff, ':');           // read up to :, discard :
C-风格字符串的函数是 istream类的方法，
而string版本是独立的函数
---------------------------------------
string版本的getline()函数从输入中读取字符串，并将其存储到
目标string中，直到发生下列三种情况之一:
1. 到达文件尾
2. 遇到分界符(默认为 '\n')，在这种情况下，将分界字符从输入流中删除，不存储它
3. 读取的字符数达到最大允许值
---------------------------------------


---------------------------------------
string snake1("cobra");
string snake2("coral");
if(snake1.length() == snake2.size())
    std::cout << "Both strings have the same length." << std::endl;
为什么这两个函数完成相同的任务呢？
length()成员来自较早版本的string类
而size()则是为提供STL兼容性而添加的
---------------------------------------


---------------------------------------
可以以多种不同的方式在字符串中搜索给定的子字符或字符
find()方法的4个版本
size_type find(const string & str, size_type pos = 0) const
size_type find(const char * s, size_type pos = 0) const
size_type find(const char * s, size_type pos = 0, size_type n)

// 查找字符, 从字符串的pos位置开始，查找字符ch.
// 如果找到, 则返回该字符首次出现的位置；否则，返回string::npos
size_type find(char ch, size_type pos = 0) const    
---------------------------------------


C++实现分配一个比实际字符串大的内存块，为字符串提供了增大空间
然而，如果字符串不断增大，超过了内存块的大小，程序将分配一个
大小为原来两倍的新内存块，以提供组后的增大空间，避免不断地分配新的内存块
方法capacity()返回当前分配给字符串的内存块的大小
方法reserve()让你能够请求内存块的最小长度


string 库实际上是基于一个模板库的
template<typename _CharT, typename _Traits, typename _Alloc>
class basic_string
{
    ...
}

--------------------------------------------------------
#include <memory>
智能指针模板类：头文件<memory>
智能指针是行为类似于指针的类对象
介绍3个可帮助管理动态内存分配的智能指针模板
auto_ptr
unique_ptr
shared_ptr
如果将new返回的地址赋给这些对象，将无需记住稍后释放这些内存
当智能指针过期时，其析构函数将使用delete来释放内存

所有智能指针类都一个explicit构造函数，该构造函数将指针作为参数
因此不需要自动将指针转换为智能指针对象
---------------------------------------------------------
为何摒弃 auto_ptr
解决 auto_ptr试图删除同一个对象两次的解决方法是：
1. 定义赋值运算符，使之执行深复制
2. 建立所有权概念，对于特定的对象，只能有一个智能指针可拥有它
3. 创建智能更高的指针
---------------------------------------------------------
unique_ptr为何优于auto_ptr
避免两个智能指针指向同一个对象的问题，更安全

unique_ptr如何能够区分安全和不安全的用法？
答案是它使用了C++11新增的移动构造函数和右值引用

unique_ptr还有一个可用于数组的变体
---------------------------------------------------------
如何选择智能指针
1. 如果程序要使用多个指向同一个对象的指针，应选择shared_ptr
2. 如果程序不需要多个指向同一个对象的指针，则可使用unique_ptr
---------------------------------------------------------




---------------------------------------------------------
标准模板库, Standard Template Library, STL
STL提供了一组表示容器，迭代器，函数对象和算法的模板

容器：是一个与数组类似的单元，可以存储若干个值
STL容器是同质的，即存储的值的类型相同

迭代器：能够用来遍历容器的对象，与能够遍历数组的指针类似，是广义指针

算法：是完成特定任务的处方

STL使得能够构造各种容器(包括数组，队列和链表)
和执行各种操作（包括搜索，排序和随机排列）

STL不是面向对象的编程，而是一种不同的编程模式----泛型编程
---------------------------------------------------------
模板类Vector
在计算中，矢量(vector)对应数组
计算矢量存储了一组可随机访问的值
---------------------------------------------------------
可对矢量执行的操作
迭代：要为vector的double类型规范声明一个迭代器，可以这样做：
vector<double>::iterator pd;

假设scores是一个vector<double>对象
vector<double> scores;
则可以使用迭代器pd执行这样的操作:
pd = scores.begin();    // have pd point to the first element
*pd = 22.3;             // dereerence pd and assign value to first element
++pd;                   // make pd point to the next element
---------------------------------------------------------
还有一个C++自动类型推断很有用的地方。例如：可以不这样做：
vector<double>::iterator pd = scores.begin();

而这样做：
auto pd = scores.begin();   // C++ automatic type deduction
---------------------------------------------------------
vector模板类也包含一些只有某些STL容器才有的办法。
push_back()是一个方便的方法，它将元素添加到矢量末尾。
这样做时，它将负责内存管理，增加矢量的长度，使之能够容纳新的成员。

erase()方法删除矢量中给定区间的元素。它接受两个迭代器参数，这些参数定义了要删除的区间。

insert()方法的功能与erase()相反。它接受3个迭代器参数，第一个参数指定了新元素的插入位置，
第二个和第三个迭代器参数定义了被插入区间，该区间通常是另一个容器对象的一部分。
vector<int> old_v;
vector<int> new_v;
...
//           [被插入的位置]        [另一个容器对象的一部分]
old_v.insert(old_v.begin(), new_v.begin() + 1, new_v.end());
----------------------------------------------------------

下面来看3个具有代表性的STL函数: for_each(), random_shuffle()和sort()

for_each()函数可用于很多容器类，它接受3个参数。
前两个是定义容器中区间的迭代器，最后一个是指向函数的指针。

for_each()函数将被指向的函数(第三个参数)应用于容器区间中的各个元素。
被指向的函数不能修改容器元素的值。

可以用for_each()函数来代替for循环。

----------------------------------------------------------
vector<Review>::iterator pr;
for(pr = books.begin(); pr != books.end(); pr++)
    ShowReview(*pr);
替换为：
for_each(books.begin(), books.end(), ShowReview);
----------------------------------------------------------

Random_shuffle()函数接受两个指定区间的迭代器参数，并随机排列该区间中的元素
该函数要求容器类允许随机访问，vector类可以做到这一点

----------------------------------------------------------
sort()函数也要求容器支持随机访问。
该函数有两个版本:
第一个版本接受两个定义区间的迭代器参数，
并使用为存储在容器中的类型元素定义的<运算符，对区间中的元素
进行操作。

vector<int> coolstuff;
...
sort(coolstuff.begin(), coolstuff.end());

如果容器元素是用户定义的对象，则要使用sort()，必须定义能够处理该类型对象的
operator<()函数。
bool operator<(const Review & r1, const Review & r2);
{
    if(r1.title < r2.title)
        return true;
    else if(r1.title == r2.title && r1.rating < r2.rating)
        return true;
    else
        return false;
}

第二个版本接受3个参数，前两个参数也是指定区间的迭代器，最后一个参数是指向
要使用的函数的指针，而不是用于比较operator<()。
返回值可转换为bool, false表示两个参数的顺序不正确
bool WorseThan(const Review & r1, const Review & r2)
{
    if(r1.rating < r2.rating)
        return true;
    else
        return false;
}
---------------------------------------------------------------
基于范围的for循环
double prices[5] = {4.99, 10.99, 6.87, 7.99, 8.49};
for(double x : prices)
    std::cout << x << std::endl

可将下列代码
for_each(books.begin(), books.end(), ShowReview);
转换为:
for(auto x : books) ShowReview(x);
----------------------------------------------------------------

STL是一种泛型编程(generic programming).
面向对象编程关注的是编程的数据方面，而泛型编程关注的是算法。
它们之间的共同点是抽象和创建可重用代码，但它们的理念绝然不同。
----------------------------------------------------------------

泛型编程旨在使用同一个find函数来处理数组、链表或任何其他容器类型。
即函数不仅独立于容器中存储的数据类型，而且独立于容器本身的数据结构。

----------------------------------------------------------------
struct Node
{
    double item;
    Node * p_next;
};

Node* find_ll(Node * head, const double & val)
{
    Node * first;
    for(start = head; start != 0; start = start->p_next)
        if(start->item == val)
            return start;
    return 0;
}
----------------------------------------------------------------
typedef double * iterator;
iterator find_ar(iterator ar, int n, const double & val)
{
    for(int i = 0; i < n; i++, ar++)
        if(*ar == val)
            return ar;  
    return 0;
}
----------------------------------------------------------------
typedef double * iterator;
iterator find_ar(iterator begin, iterator end, const double & val)
{
    iterator ar;
    // 如何谓词已到达最后一个值，这里使用了超尾迭代器
    for(ar = begin; ar != end; ar++)    
        if(*ar == val)
            return ar;
    return end;
}
----------------------------------------------------------------
struct Node
{
    double item;
    Node * p_next;
};

class iterator
{
private:
    Node * pt;

public:
    iterator() : pt(0) {}
    iterator(Node * pn) : pt(pn) {}
    double operator*() { return pt->item; }
    iterator & operator++()     // for ++it
    {
        pt = pt->p_next;
        return *this;
    }

    iterator operator++(int)    // for it++    
    {
        iterator tmp = *this;
        pt = pt->p_next;
        return temp;
    }
};

iterator find_ll(iterator head, const double & val)
{
    iterator start;
    // 如何谓词已到达最后一个值，这里使用了存储在最后一个节点中的空值
    for(start = head; start != 0; ++start)
        if(*start == val)
            return start;
    return 0;
}
----------------------------------------------------------------
STL遵循上面介绍的方法
首先，每个容器类(vector, list, deque等)定义了相应的迭代器类型。
对于其中的某个类，迭代器可能是指针；
而对于另一个类，则可能是对象。
不管实现方式如何，迭代器都将提供所需的操作，如*和++。
其次，每个容器类都有一个超尾标记，当迭代器递增到超越容器的最后一个值后，
这个值将被赋给迭代器。每个容器类都有begin()和end()方法，它们分别返回
一个指向容器的第一个元素和超尾位置的迭代器。
----------------------------------------------------------------
使用C++新增的自动类型推断可进一步简化：
对于矢量或列表，都可使用如下代码：
for(auto pr = scores.begin(); pr != scores.end(); pr++)
{
    std::cout << *pr << std::endl;
}
----------------------------------------------------------------
迭代器类型
不同的算法对迭代器的要求也不同。例如，查找算法需要定义++运算符，以便迭代器
能够遍历整个容器；它要求能够读取数据，但不要求能够写数据。
排序算法要求能够随机访问，以便能够交换两个不相邻的元素。

STL定义了5中迭代器，并根据所需的迭代器类型对算法进行了描述：
输入迭代器
输出迭代器
正向迭代器
双向迭代器
随机访问迭代器

----------------------------------------------------------------
例如：
find()的原型与下面类似，下面的原型指出需要一个输入迭代器
template<class InputIterator, class T>
InputIterator find(InputIterator first, InputIterator last, const T& value);
----------------------------------------------------------------
下面的原型指出排序算法需要一个随机访问迭代器：
template<class RandomAccessIterator>
void sort(RandomAccessIterator first, RandomAccessIterator last);
----------------------------------------------------------------

对于这5中迭代器，都可以执行：
解除引用操作，即 *运算符
==运算符
!=运算符

----------------------------------------------------------------
1. 输入迭代器
术语“输入”是从程序的角度说的，即来自容器的信息被视为输入，就像来自键盘的信息
对程序来说输入一样。因此，输入迭代器可被程序用来读取容器中的信息，
而不能修改容器中的值。

输入迭代器必须能够访问容器中所有的值。
注意，输入迭代器是单向迭代器，可以递增，但不能倒退。
----------------------------------------------------------------
2. 输出迭代器
术语“输出”来指用于将信息从程序传输给容器的迭代器，因此程序的输出就是容器的输入。
输出迭代器与输入迭代器相似，只是解除引用让程序能修改容器值，而不能读取。
也许你会感到奇怪，能够写，却不能读。发送到显示器上的输出就是如此。
cout可以修改发送到显示器的字符流，却不能读取屏幕上的内容。
----------------------------------------------------------------
简而言之，
对于单通行、只读算法，可以使用输入迭代器
而对于单通行、只写算法，则可以使用输出迭代器
----------------------------------------------------------------
3. 正向迭代器
与输入迭代器和输出迭代器相似，正向迭代器只使用++运算符来遍历容器，
所以它每次沿容器向前移动一个元素；然而，与输入和输出迭代器不同的是，
它总是按相同的顺序遍历一系列值。
另外，将正向迭代器递增后，仍然可以对前面的迭代器值解除引用，并可以得到
相同的值。这些特征使得多次通行算法称为可能。

正向迭代器既可以使得能够读取和修改数据，也可以使得只能读取数据：
int * priw;         // read-write iterator
const int * pir;    // read-only iterator
----------------------------------------------------------------
4. 双向迭代器
假设算法需要能够双向遍历容器，情况将如何呢？
例如，reverse函数可以交换第一个元素和最后一个元素、将指向第一个元素的指针加1、
将指向第二个元素的指针减1，并重复这种处理过程。
双向迭代器具有正向迭代器的所有特性，同时支持两种(前缀和后缀)递减运算符
----------------------------------------------------------------
5. 随机访问迭代器
有些算法(如标准排序和二分检索)要求能够直接跳到容器中的任何一个元素，
这叫做随机访问，需要随机访问迭代器。
随机访问迭代器具有双向迭代器的所有特性，
同时添加了支持随机访问的操作(如指针增加运算符) 和 
用于对元素进行排序的 关系运算符。
----------------------------------------------------------------


----------------------------------------------------------------
迭代器层次结构：

输入迭代器
输出迭代器
正向迭代器：输入迭代器 +  + 自己的功能
双向迭代器：正向迭代器 + 自己的功能
随机访问迭代器：正向迭代器 + 自己的功能
----------------------------------------------------------------

为什么需要这么多迭代器呢？
目的是为了在编写算法尽可能使用要求最低的迭代器，并让它适用于容器的最大区间。
通过使用级别最低的输入迭代器，find()函数便可用于任何包含可读取值的容器
sort()函数由于需要随机访问迭代器，所以只能用于指出这种迭代器的容器
----------------------------------------------------------------


----------------------------------------------------------------
1. 将指针用作迭代器
迭代器是广义指针，而指针满足所有的迭代器要求。迭代器是STL算法的接口，
而指针是迭代器，因此STL算法可以使用指针来对基于指针的非STL容器进行操作。
例如，可将STL算法用于数组。
----------------------------------------------------------------
假设Receipts是一个double数组，并要按升序对它进行排序：
const int SIZE = 100;
double Receipts[SIZE];

STL sort()函数接受指向容器第一个元素的迭代器和指向超尾的迭代器作为参数。
&Receipts[0](或Receipts)是第一个元素的地址，&Receipts[SIZE](或Receipts + SIZE)
是数组最后一个元素后面的元素的地址。
因此，下面的函数调用对数组进行排序：
sort(Receipts, Receipts + SIZE);
C++确保了表达式Receipts + n是被定义的，只要该表达式的结果位于数组中。
因此，C++支持将超尾概念用于数组，使得可以将STL算法用于常规数组。
由于指针是迭代器，而算法是基于迭代器的，这使得可将STL算法用于常规数组。
同样，可以经STL算法用于自己设计的数组形式，只要提供适当的迭代器和超尾指示器即可。



----------------------------------------------------------------
copy(), ostream_iterator, istream_iterator
----------------------------------------------------------------
STL提供了一些预定义迭代器。
有一种算法，名为copy()，可以将数据从一个容器复制到另一个容器中。
这种算法是以迭代器方式实现的，所以它可以从一种容器到另一种容器进行赋值，
甚至可以在数组之间复制，因为可以将指向数组的指针用作迭代器。
例如，
下面的代码将一个数组复制到一个矢量中：
int casts[10] = {6, 7, 2, 9, 4, 11, 8, 7, 10, 5};
vector<int> dice[10];
copy(casts, casts + 10, dice.begin());
copy() 的前两个迭代器参数表示要复制的范围，
最后一个迭代器参数表示要将第一个元素复制到什么位置。
前两个参数必须是（或最好是）输入迭代器，
最后一个参数必须是（或最好是）输出迭代器


假设要将信息复制到显示器上。
如果有一个表示输出流的迭代器，则可以使用copy().
STL为这种迭代器提供了ostream_iterator模板，
用STL的话，该模板是输出迭代器概念的一个模型，
它也是一个适配器——— 一个类或函数，可以将一些
其他接口转换为STL使用的接口。可以通过包含头文件
iterator并作下面的声明来创建这种迭代器：
#include <iterator>
...
ostream_iterator<int, char> out_iter(cout, " ");

out_iter迭代器现在是一个接口，让你能够使用cout来显示信息。
第一个模板参数（这里为int）指出了被发送给输出流的数据类型
第二个模板参数（这里为char）指出了输出流使用的字符类型

可以这样使用迭代器：
*out_iter++ = 15;   // works line cout << 15 << " ";
对于常规指针，这意味着将15赋给指针指向的位置，然后将指针加1
但对于该ostream_iterator,这意味着将 15和由空格组成的字符串
发送到cout管理的输出流中，并为下一个输出操作做好了准备。
可以将copy()用于迭代器，如下所示：

copy(dice.begin(), dice.end(), out_iter);
这意味着将dice容器的整个区间复制到输出流中，即显示容器的内容
也可以不创建命名的迭代器，而直接构建一个匿名迭代器。
即可以这样使用适配器：
copy(dice.begin(), dice.end(), ostream_iterator<int, char>(cout, " "));


iterator头文件还定义了一个istream_iterator模板，使istream输入可用作迭代器接口
它是一个输入迭代器概念的模型，可以使用两个istream_iterator对象来定义copy()输入范围
copy(istream_iterator<int, char>(std::cin), istream_iterator<int, char>(), dice.begin());
与ostream_iterator相似，istream_iterator也使用两个模板参数。
第一个参数指出要读取的数据类型，
第二个参数指出输入流使用的字符类型。
使用构造函数参数cin意味着使用由cin管理的输入流，省略构造函数参数表述输入失败，
因此上述diamagnetic从输入流中读取，直到文件结尾、类型不匹配或出现其他输入故障为止


----------------------------------------------------------------
其他有用的迭代器
除了ostream_iterator和istream_iterator之外，头文件iterator还提供了
其他一些专用的预定义迭代器类型。
它们是reverse_iterator, back_insert_iterator,front_insert_interator
和insert_iterator.

reverse_iterator执行递增操作将导致它被递减
为什么不直接对常规迭代器进行递减呢？
主要原因是为了简化对已有的函数的使用。
ostream_iterator<int, char> out_iter(cout, " ");
copy(dice.begin(), dice.end(), out_iter);   // display in forward order


----------------------------------------------------------------
现在假设要反向打印容器的内容：
vector类有一个名为 rbegin() 的成员函数  ->(指向超尾)
和一个名为 rend()的成员函数，           ->(指向第一个元素)
前者返回一个指向超尾的反向迭代器，
后者返回一个指向第一个元素的反向迭代器

因为对迭代器执行递增操作将导致它被递减，
所以可以使用下面的语句来反向显示内容：

copy(dice.rbegin(), dice.rend(), out_iter);
甚至不必声明反向迭代器
----------------------------------------------------------------

注意：
rbegin() 和 end() 返回相同的值（超尾），
但类型不同（reverse_iterator 和 iterator）.
同样，rend()和begin()也返回相同的值（指向第一个元素的迭代器）
但类型不同

----------------------------------------------------------------

必须对反向指针做一种特殊补偿。
假设rp是一个被初始化为dice.rbegin()的反转指针，
那么*rp是什么呢？
因为rbegin()返回超尾，
因此不能对该地址进行解除引用。
同样，如果rend()是第一个元素的地址，则copy()必须提早一个位置停止，
因为区间的结尾处不包括在区间中

反向指针通过先递减，再解除引用解决了这两个问题。
即*rp将在 *rp的当前值之前对迭代器执行解除引用。
也就是说，如果rp指向为止6,则*rp将是位置5的值。

----------------------------------------------------------------

copy()有哪些用途：
1. 将信息从一个容器复制到另一个容器
2. 将信息从容器复制到输出流
3. 将输入流复制到容器中
4. 将信息插入到另一个容器中



----------------------------------------------------------------
STL具有容器概念和容器类型
概念：是具有名称的通用别名，如容器，序列容器，关联容器
容器类型：是可用于创建具体容器对象的模板
----------------------------------------------------------------
容器类型有：
deque
list
queue
priority_queue
stack
vector
map
multimap
set
mulstiset
bitset
forward_list
unordered_map
unordered_multimap
unordered_set
unordered_multiset
----------------------------------------------------------------
1. 容器概念
容器概念指定了所有STL容器类都必须满足的一系列要求

不能将任何类型的对象存储再容器中，具体地说，
类型必须是可复制构造的和可赋值的。

基本容器不能保证其元素都按特定的顺序存储，
也不能保证元素的顺序不变，但对概念进行改进后，
则可以增加这样的保证。所有的容器都提供某些特征和操作。

----------------------------------------------------------------
复杂度：
编译时间：操作将在编译时执行，执行时间为0

固定时间：操作发生在运行阶段，但独立于对象中的元素数目

线性时间：时间与元素数目成正比
----------------------------------------------------------------

序列：
可以通过要求来改进基本的容器概念。
序列(sequence)是一种重要的改进，
因为7种STL容器类型
deque, 
forward_list, 
list, 
queue, 
priority_queue,
stack和
vector都是序列

队列让您能够在队尾添加元素，在队首删除元素。
deque表示的双端队列允许在两端添加和删除元素

array也被归类到序列容器，虽然它并不满足序列的所有要求

序列还要求其元素按严格的线性顺序排列，即存在第一个元素，
最后一个元素，除第一个元素和最后一个元素外，
每个元素前后都分别有一个元素。
数组和链表都是序列。

因为序列中的元素具有确定的顺序，因此可以执行诸如将值插入到
特定位置、删除特定区间等操作。


为何list和deque定义了push_front(),而没有为vector定义？
假设要将一个新值插入到包含100个元素的矢量的最前面。
要腾出空间，必须将第99个元素移到位置100，然后将第98个元素移动到
位置99，依次类推。这种操作的复杂度为线性时间，
因为移动100个元素所需的时间为移动单个元素的100倍。
链表和双端队列的设计允许将元素添加到前端，而不用移动其他元素，
所以它们可以以固定时间的复杂度来实现push_front()


下面详细介绍这7种序列容器类型
----------------------------------------------------------------
(1) vector
在vector头文件中声明
vector是数组的一种类表示，它提供了自动内存管理功能，
可以动态地改变vector对象的长度，并随着元素的添加和删除而增加和缩小。
它提供了对元素的随机访问。在尾部添加和删除元素的时间是固定的，但在头部或
中间插入和删除元素的复杂度为线性时间。

除序列外，vector还是 可反转容器(reversible container)概念的模型
这增加了两个类方法：rbegin()和 rend()，
前者返回一个指向反转序列的第一个元素的迭代器
后者返回反转序列的超尾迭代器

vector模板类是最简单的序列类型，除非其他类型的特殊有点能够更好地满足
程序的要求，否则应默认使用这种类型


(2) deque
在deque头文件中声明
deque表示双端队列 double-ended queue
在STL中，其实现类似于vector容器，支持随机访问。
主要区别在于，从deque对象的开始位置插入和删除元素的时间是固定的，
而不像vector中那样是线性时间的。
所以，如果多数操作发生在序列的起始和结尾处，则应考虑使用deque数据结构


(3) list
list模板类在 list头文件中声明
表示双向链表
除了第一个和最后一个元素外，每个元素都与前后的元素相链接，
这意味着可以双向遍历链表。
list和vector之间关键的区别在于，list在链表中任一位置进行
插入和删除的时间都是固定的。
vector模板提供了除结尾处外的线性时间的插入和删除，在结尾处，
它提供了固定时间的插入和删除。
因此，vector强调的是通过随机访问进行快速访问，
而list强调的是元素的快速插入和删除

与vector相似，list也是可反转容器
与vector不同的是，list不支持数组表示法和随机访问。

在链表中插入新元素并不会移动已有的元素，
而只是修改链接信息。指向某个元素的迭代器仍然指向该元素，
但它链接的元素可能与以前不同。

除[序列]和[可反转容器]的函数外，list模板类还包含了链表专用的成员函数。

1. void merge(list<T, Alloc>& x)
将链表x 与 调用链表 合并。两个链表必须已经排序。
合并后的经过排序的链表保存在调用链表中，x为空。

2. void remove(const T & val)
从链表中删除val的所有实例

3. void sort()
使用<运算符对链表进行排序

4. void splice(iterator pos, list<T, Alloc> x)
将链表x的内容插入到pos的前面，x将为空。

5. void unique()
将连续的相同元素压缩为单个元素

----------------------------------------------------------------
insert() 和 splice() 之间的主要区别在于：
insert()将原始区间的副本插入到目标地址，
而 splice() 则将原始区间移到目标地址。
因此，在one的内容与three合并后，one为空。

(4) 程序说明


(5) list工具箱
list方法组成了一个方便的工具箱。
例如，假设有两个邮件列表要整理，
则可以对每个列表进行排序，合并它们，
然后使用unique()来删除重复的元素。


(6) forward_list
C++11新增了容器类 forward_list,它实现了单链表
在这种链表中，每个节点都只链接到下一个节点，
而没有链接到前一个节点。
因此forward_list只需要正向迭代器，而不需要双向迭代器
因此，不同于vector和list,forward_list是不可反转的容器。


(7) queue
在头文件 queue中声明的一个适配器类
ostream_iterator模板就是一个适配器，让输出流能够使用迭代器接口
同样，queue模板让底层类(默认为deque)展示典型的队列接口

queue模板的限制比 deque更多。
它不仅不允许随机访问队列元素，甚至不允许遍历队列。
它把使用限制在定义队列的基本操作上，可以将元素添加到队尾、
从队首删除元素、查看队首和队尾的值、检查元素数目和
测试队列是否为空

pop()是一个删除数据的方法，而不是检索数据的方法
如果要使用队列中的值，应首先使用front()来检索这个值，
然后使用pop()将它从队列中删除

(8) priority_queue模板类
在头文件 queue中声明的另一个适配器类，
它支持的操作与queue相同

两者之间的主要区别在于，
在priority_queue中，最大的元素被移到队首。
内部区别在于，默认的底层类是vector

可以修改用于确定哪个元素放到队首的比较方法，
方法是提供一个可选的构造函数参数：
priority_queue<int> pq1;
priority_queue<int> pq2(greater<int>);
greater<>()函数是一个预定义的函数对象


(9) stack
在头文件 stack中声明的一个适配器类
它给底层类(默认情况下为 vector)提供了典型的栈接口

stack模板的限制比vector更多。
它不仅不允许随机访问栈元素，甚至不允许遍历栈
它把使用限制在定义栈的基本操作上，
既可以将压入推到栈顶、从栈顶弹出元素、
查看栈顶的值、检查元素数目和测试栈是否为空

与queue相似，如果要使用栈中的值，必须首先使用top()来检索这个值，
然后使用pop()将它从栈中删除


(10) array
模板类array 是在头文件array中定义的，
它并非STL容器，因为其长度是固定的
因此，array没有定义调整容器大小的操作，
如 push_back()和insert(), 但定义了对它来说有意义的成员函数
如 operator[] 和 at()

可将很多标准STL算法用于array对象，如copy() 和 for_each()

----------------------------------------------------------------
关联容器 associative container,是对容器概念的另一个改进
关联容器将值与键关联在一起，并使用键来查找值

对于容器X,表达式X::value_type通常指出了存储在容器中的值类型
对于关联容器来说，表达式X::key_type指出了键的类型

关联容器的有点在于，它提供了对元素的快速访问
与序列相似，关联容器也允许插入新元素，但不能指定元素的插入位置
原因是关联容器通常有 用于确定数据放置位置的算法，以便能够快速检索信息


关联容器通常是使用某种树实现的
树是一种数据结构，其根节点链接到一个或两个节点
而这些节点又链接到一个或两个节点，从而形成分支节后
像链表一样，节点使得添加或删除数据项比较简单
但对于链表，树的查找速度更快

STL提供了4中关联容器
set
multiset
map
multimap

最简单的关联容器是set，
其值类型与键相同，
键是唯一的，这意味着集合中不会有多个相同的键
确实，对于set来说，值就是键。

multiset类似于set，
只是可能有多个值的键相同

STL set模拟了多个概念，
它是关联集合，可反转、可排序，且键是唯一的，所以不能存储多个相同的值。
与vector和list相似，set也使用模板参数来指定要存储的值类型


set_union           // 并集
set_intersection    // 交集
set_difference      // 两个集合的差

set中两个有用的set方法是
lower_bound() 将键作为参数并返回一个迭代器，
该迭代器指向集合中第一个不小于键参数的成员

upper_bound() 
将键作为参数，并返回一个迭代器
该迭代器指向集合中第一个大于键参数的成员

----------------------------------------------------------------
无序关联容器
无序关联容器是对容器概念的另一种改进
与关联容器一样，无序关联容器也将值与键关联起来，并使用键来查找值
但底层的差别在于，关联容器是基于树结构的，
而无序关联容器是基于数据结构哈希表的
这旨在提高添加和删除元素的素服以及提高查找算法的效率

有4中无序关联容器，它们是
unordered_set
unordered_multiset
unordered_map
unordered_multimap

----------------------------------------------------------------
16.5 函数对象

很多STL算法都使用函数对象----也叫函数符 functor
函数符是可以以 函数方式 与 ()结合使用的任意对象。
这包括函数名、指向函数的指针 和 重载了()运算符的类对象，即定义了函数 operator()()的类
例如，可以向这样定义一个类：
class Linear
{
private:
    double slope;
    double y0;

public:
    Linear(double s1_ = 1, double y_ = 0)
        : slope(s1_), y0_(y_) {}
    double operator()(double x) { return y0 + slope * x; }
};
这样，重载的 ()运算符 将使得能够像函数那样使用 Linear对象：
Linear f1;
Linear f2(2.5, 10.0);
double y1 = f1(12.5);
double y2 = f2(0.4);

----------------------------------------------------------------
还记得函数 for_each吗？
for_each(books.begin(), books.end(), ShowReview);

通常，第3个参数可以是常规函数，也可以是函数符
实际上，这提出了一个问题：如何声明第3个参数呢？
不能把它声明为函数指针，因为函数指针指定了参数类型
由于容器可以包含任意类型，所以预先无法直到应使用哪种参数类型
STL通过使用模板解决了这个问题：

for_each的原型看上去就像这样：
template<class InputIterator, class Function>
Function for_each(InputIterator first, InputIterator last, Function f);

ShowReview()的原型如下：
void ShowReview(const Review &);

这样，标识符ShowReview的类型将为 void(*)(const Review &),
这也是赋给参数Function的类型。
对于不同的函数调用，Function参数可以表示具有重载 ()运算符的类类型

最终，
for_each()代码将具有一个使用 f()的表达式
在ShowReview()示例中，f是指向函数的指针，而f()调用该函数
如果最后的for_each()参数是一个对象，则f()将是调用其重载的 ()运算符的对象

----------------------------------------------------------------
函数符概念

正如STL定义了容器和迭代器的概念一样，它也定义了函数符概念
#生成器 generator：是不用参数就可以调用的函数符
#一元函数 unary function：是用一个参数就可以调用的函数符
#二元函数 binary function：是用两个参数就可以调用的函数符

例如，
提供给for_each()的函数符应当是一元函数，因为它每次用于一个容器元素

当然，这些概念都有相应的改进版：
#返回bool值的一元函数是谓词 predicate
#返回bool值得二元函数是二元谓词 binary predicate

一些STL函数需要谓词参数或二元谓词参数
例如，
sort()的一个版本，即将二元谓词作为其第3个参数：
bool WorseThan(const Review & r1, const Review & r2);
...
sort(books.begin(), books.end(), WorseThan);


list模板有一个将谓词作为参数的remove_if()成员，
该函数将谓词应用于区间中的每个元素，
如果谓词返回true，则删除这些元素
例如，
下面的代码删除链表three中所有大于 100的元素：
bool tooBig(int n) { return n > 100; }
list<int> scores;
...
socres.remove_if(tooBig);


----------------------------------------------------------------
假设已经有了一个接受两个参数的模板函数：
template <class T>
bool tooBig(const T & val, const T & lim)
{
    return val > lim;
}

则可以使用类将它转换为单个参数的函数对象：

template <class T>
class TooBig2
{
private:
    T cutoff;

public:
    TooBig2(const T & t) : cutoff(t) {}
    bool operator()(const T & v) { return tooBig<T>(v, cutoff); }
};

即可以这样做：
TooBig2<int> tB100(100);
int x;
std::cin >> x;
if( tB100(x) )
    ...

因此，调用 tB100(x) 相当于调用 tooBig(x, 100),
但两个参数的函数被转换为单参数的函数对象，
其中第二个参数被用于构建函数对象。
简而言之，类函数符 TooBig2是一个函数适配器，是函数能够满足不同的接口


使用C++11的初始化列表功能，可将如下代码：
int vals[10] = {50, 100, 90, 180, 60, 210, 415, 88, 188, 201};
list<int> yadayada(vals, vals + 10);
list<int> etcetera(vals, vals + 10);
替换为下述代码：
list<int> yadayada = {50, 100, 90, 180, 60, 210, 415, 88, 188, 201};
list<int> etcetera = {50, 100, 90, 180, 60, 210, 415, 88, 188, 201};


----------------------------------------------------------------
预定义的函数符
STL定义了多个基本函数符，它们执行诸如
将两个值相加、比较两个值是否相等操作
提供这些函数对象是为了支持将函数作为参数的STL函数


----------------------------------------------------------------
考虑函数transform()
它有两个版本
----------------------------------------------------------------
第一个版本接受4个参数，
前两个参数是指定容器区间的迭代器
第3个参数是指定将结果复制到哪里的迭代器，
最后一个参数是一个函数符，它被应用于区间中的每个元素，生成结果中的新元素

const int LIM = 5;
double arr1[LIM] = {36, 39, 42, 45, 48};
vector<double> gr8(arr1, arr1 + LIM);
ostream_iterator<double, char> out(cout, " ");
transform(gr8.begin(), gr8.end(), out, sqrt);

上述代码计算每个元素的平方根，并将结果发送到输出流
----------------------------------------------------------------
第二个版本使用一个接受两个参数的函数
并将该函数用于两个区间中元素。
它用另一个参数（即第3个）表示第二个区间的起始位置。
例如，
如果m8是另一个vector<double> 对象，mean(double, double) 返回两个值的平均值，
则下面的代码将输出来自 gr8 和 m8的值的平均值：
transform(gr8.begin(), gr8.end(), m8.begin(), out, mean);

现在假设要将两个数组相加。
不能将+作为参数，因为对于类型double来说，
+是内置的运算符，而不是函数。
可以定义一个将两个数相加的函数，然后使用它：
double add(double x, double y) { return x + y; }
...
transform(gr8.begin(), gr8.end(), m8.begin(), out, add);


然而，这样必须为每种类型单独定义一个函数。
更好的办法是定义一个模板，除非STL已经有一个模板了，这样就不必定义。
头文件 functional 定义了多个模板类函数对象，其中包括 plus<>()
可以用plus<> 类来完成常规的相加运算

#include <functional>
...
plus<double> add;
double y = add(2.2, 3.4);
它使得将函数对象作为参数很方便：
transform(gr8.begin(), gr8.end(), m8.begin(), out, plus<double>());


----------------------------------------------------------------

对于所有内置的算数运算符、关系运算符和逻辑运算符，
STL都提供了等价的函数符。
它们可以用于处理C++内置类型或任何用户定义类型
+       plus
-       minus
*       multiplies
/       divides
%       modulus
-       negate
==      equal_to
!=      not_equal_to
>       greater
<       less
>=      greater_equal
<=      less_equal
&&      logical_and
||      logical_or  
!       logical_not

----------------------------------------------------------------
自适应函数符和函数适配器

上面列出的预定义函数符都是自适应的
实际上 STL有5个相关的概念：
自适应生成器-adaptable generator
自适应一元函数-adaptable unary function
自适应二元函数-adaptable binary function
自适应谓词-adaptable predicate
自适应二元谓词-adaptable binary predicate

使函数称为自适应的原因是，它携带了表示参数类型和返回类型的typedef成员
这些成员分别是 result_type, first_argument_type 和 second_argument_type
它们的作用是不言自明的

例如，
plus<int>对象的返回类型被标识为 plus<int>::result_type
这是int的typedef

函数符自适应性的意义在于：函数适配器对象可以使用函数对象，
并认为存在这些typedef成员。
例如，
接受一个自适应函数符参数的函数可以使用result_type成员
来声明一个与函数的返回类型匹配的变量

STL提供了使用这些工具的函数适配器类。
例如，
假设要将矢量 gr8 的每个元素都增加 2.5倍，
则需要使用接受一个一元函数参数的 transform()版本，
就像前面的例子那样：
transform(gr8.begin(), gr8.end(), out, sqrt);

multiplies()函数符可以执行乘法运算，但它是二元函数
因此需要一个函数适配器，将接受两个参数的函数符转换为接受一个参数的函数符
STL使用 bind1st 和 bind2nd类自动完成这一过程，
它将自适应二元函数转换为自适应一元函数

bind1st将常数赋给第一个参数
bind2nd将常数赋给第二个参数，而不是第一个参数

来看bind1st, 假设有一个自适应二元函数对象 f2(),则可以创建
一个bind1st对象，该对象与一个将被用作f2()的第一个参数的特定值(val)相关联

bind1st(f2, val) f1;
这样，使用单个参数调用 f1(x)时，返回的值与将val作为第一个参数、
将f1()的参数作为第二参数调用 f2()返回的值相同。
即 f1(x) 等价于 f2(val, x), 只是前者时一元函数，而不是二元函数
f2()函数被适配
同样，仅当 f2()是一个自适应函数时，这才能实现

然而，STL提供了函数 bind1st(), 以简化bider1st类的使用
例如，
要将二元函数multiplies()转换为将参数乘以 2.5的一元函数，则可以这样做：

bind1st(multiplies<double>(), 2.5);

因此，将gr8中的每个元素与 2.5相乘，并显示结果的代码如下：
transform(gr8.begin(), gr8.end(), out, bind1st(multiplies<double>(), 2.5));


----------------------------------------------------------------
算法
----------------------------------------------------------------
STL包含很多处理容器的非成员函数，
前面已经介绍过其中的一些：
sort()
copy()
find()
random_shuffle()
set_union()
set_intersection()
set_diference()
transform()

可能已经注意到，它们的总体设计是相同的，
都使用迭代器来标识要处理的数据区间和结果的放置位置
----------------------------------------------------------------
对于算法函数设计，有两个主要的通用部分。
首先，它们都使用模板来提供泛型
其次，它们都使用迭代器来提供访问容器中数据的通用表示

因此，
copy()函数可用于将double值存储在数组中的容器，
将string值存储在链表中的容器，
也可用于将用户定义的对象存储在树结构中的容器
因为指针是一种特殊的迭代器，因此诸如copy()等STL函数可用于常规数组

----------------------------------------------------------------

统一的容器设计使得不同类型的容器之间具有明显关系。
例如，
可以使用copy()将常规数组中的值复制到vector对象中，
将vector对象中的值复制到list对象中
将list对象中的值复制到set对象中
可以用==来比较不同类型的容器，如deque和vector
之所以能够这样做，是因为容器重载的 == 运算符使用迭代器来
比较内容，因此如果deque对象和vector对象的内容相同，
并且排列顺序也相同，则它们是相等的



----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
STL将算法库分成4组：
非修改式序列操作
修改式序列操作
排序和相关操作
通用数字运算

前3组在头文件 algorithm中描述，
第4组是专用于数值数据的，也有自己的头文件，称为 numeric
----------------------------------------------------------------
非修改式序列操作对区间中的每个元素进行操作，
这些操作不修改容器的内容
例如，
find()和 for_each()就属于这一类

----------------------------------------------------------------
修改式序列操作也对区间中的每个元素进行操作
然而，顾名思义，它们可以修改容器的内容
可以修改值，也可以修改值得排列顺序
transform()
random_shuffle()
copy()
属于这一类

----------------------------------------------------------------

排序和相关操作包括多个排序函数，sort()和其他各种函数，包括集合操作

----------------------------------------------------------------

数字操作包括将区间的内容累积、计算两个容器的内部乘积、
计算小计、计算相邻对象差的函数

----------------------------------------------------------------
算法的通用特征
STL函数使用迭代器和迭代器区间
从函数原型可知有关迭代器的假设
例如，
copy()函数的原型如下：
template<class InputIterator, class OutputIterator>
OutputIterator copy(InputIterator first, InputIterator last,
                    OutputIterator result);

虽然标识符InputIterator和OutputIterator都是模板参数，
所以它们就像T和U一样。
然而，STL文档使用模板参数名称来表示参数模型的概念
因此上述声明告诉我们，区间参数必须是输入迭代器或更高级别的迭代器，
而指示结果存储位置的迭代器必须是输出迭代器或更高级别的迭代器

对算法进行分类的方式之一是按结果放置的位置进行分类
有些算法就地完成工作，有些则创建拷贝
例如，
在sort()函数完成时，结果被存放在原始数据的位置上
因此，sort()是就地算法(in-place algotithm)，
而copy()函数将结果发送到另一个位置，所以它是复制算法(copying algorithm)

transform()函数可以以这两种方式完成工作，
与copy()相似，它使用输出迭代器指示结果的存储位置
与copy()不同的是，transform()允许输出迭代器指向输入区间，
因此它可以用及算法结果覆盖原来的值

有些算法有两个版本：就地版本和复制版本
STL的约定是，复制版本的名称将以 _copy结尾
复制版本将接受一个额外的输出迭代器参数，
该参数指定结果的放置位置
例如，
函数replace()的原型如下：
template<class ForwardIterator, class T>
void replace(ForwardIterator first, ForwardIterator last,
            const T & old_value, const T & new_value);
它将所有的old_value替换为new_value,这是就地发生的
由于这种算法同时读写容器元素，因此迭代器类型必须是
ForwardIterator或更高级别的。
复制版本的原型如下：
template<class InputIterator, class OutputIterator, class T>
OutputIterator replace_copy(InputIterator first, InputIterator last,
                            OutputIterator result,
                            const T & old_value, const T & new_value);
在这里，结果被复制到result指定的新位置，
因此对于指定区间而言，只读输入迭代器足够了。

注意，replace_copy()的返回类型为 OutputIterator。
对于复制算法，统一的约定是：
返回一个迭代器，该迭代器指向复制的最后一个值后面的一个位置


另一个常见的变体是：有些函数有这样的版本，
即根据将函数应用于容器元素得到的结果来执行操作。
这些版本的名称通常以 _if结尾。
例如，
如果将函数用于旧值时，返回的值为true，
则replace_if()将把旧值替换为新的值
下面是该函数的原型：
template<class ForwardIterator, class Predicate class T>
void replace_if(ForwardIterator first, ForwardIterator last,
                Predicate pred, const T & new_value);

与InputIterator一样，Predicate也是模板参数名称，
可以为T或U。然而，STL选择用Predicate来提醒用户，
实参应模拟Predicate概念
同样，STL使用诸如Generator 和 BinaryPredicate等术语
来指示必须模拟其他函数对象概念的参数。
----------------------------------------------------------------
----------------------------------------------------------------
STL 和 string类
string类虽然不是STL的组成部分，但设计它时考虑到了STL
例如，它包含
begin()
end()
rbegin()
rend()
等成员，因此可以使用STL接口。

排列组合就是重新安排容器中元素的顺序
next_permutation()算法将区间内容转换为下一种排列方式    // permutation 置换，排列
对于字符串，排列按照字母递增的顺序进行
如果成功，该算法返回true
如果区间已经处于最后的序列中，则该算法返回false
要得到区间内容的所有排列组合，应从最初的顺序开始，为此程序使用了STL算法sort()


----------------------------------------------------------------
函数和容器方法
有时可以选择使用STL方法或STL函数。通常方法是最好的选择。
首先，它更适合于特定的容器
其次，作为成员函数，它可以使用模板类的内存管理工具，从而在需要时调整容器的长度


例如，假设有一个由数字组成的链表，并要删除链表中某个特定值(例如4)的
所有实例。如果la是一个list<int>对象，则可以使用链表的remove()方法：
la.remove(4);

还有一个名为 remove()的STL算法，它不是由对象调用，而是接受区间参数。
因此，如果lb是一个list<int>对象，则调用该函数的代码如下：
remove(lb.begin(), lb.end(), 4);

然而，由于该remove()函数不是成员，因此不能调整链表的长度。
它将没被删除的元素放在链表的开始位置，并返回一个指向新的超尾值的迭代器。
这样，便可以用该迭代器来修改容器得长度
例如，
可以使用链表的erase()方法来删除一个区间，该区间描述了链表中不再需要的部分

总结：
尽管方法通常更适合，但非方法函数更通用。
可以将它们用于数组，string对象，STL容器，
还可以用它们来处理混合的容器类型。
例如，
将矢量容器中的数据存储到链表或集合中。


----------------------------------------------------------------
STL是一个库，其组成部分被设计成协同工作。
STL组件是工具，但也是创建其他工具的基本部件。


----------------------------------------------------------------
其他库

C++还提供了其他一些类库
例如，
头文件complex为复数提供了类模板complex,
包含用于float，long和long double的具体化。
这个类还提供了标准的复数运算及能够处理复数的标准函数

C++新增的头文件random提供了更多的随机数功能

第14章介绍了头文件valarray提供的模板类valarray,
这个类模板被设计成用于表示数值数组，支持各种数值数组操作
例如，
将两个数组的内容相加、对数组的每个元素应用数学函数
以及对数组进行线性代数运算

----------------------------------------------------------------
vector，valarray和array
C++为何提供以上三个数组模板

vector模板类
是一个容器类和算法系统的一部分，它支持面向容器的操作，
如排序、插入、重新排列、搜索、将数据转移到其他容器中等

valarray类模板
是面向数值计算的，不是STL的一部分。
例如，
它没有push_back()和insert()方法
但为很多数学计算提供了一个简单直观的接口

array是为替代内置数组而设计的，
它通过提供更好、更安全的接口，
让数组更紧凑，效率更高

Array表示长度固定的数组，
因此不支持push_back() 和 insert()，
但提供了多个STL方法，
包括begin(),end(),rbegin()和rend(),
这使得很容易将STL算法用于array对象。

----------------------------------------------------------------
例如，
假设有如下声明：
vector<double> ved1(10), ved2(10), ved3(10);
array<double, 10> vod1, vod2, vod3;
valarray<double> vad1(10), vad2(10), vad3(10);

要将两个数组中第一个元素的和赋给第三个数组的第一个元素，
使用vector类时，可以这样做：
transform(ved1.begin(), ved1.end(), ved2.begin(), 
        ved3.begin(), plus<double>());

对于array类，也可以这样做：
transform(vod1.begin(), vod1.end(), vod2.begin(), 
        vod3.begin(), plus<double>());

然而，valarray类重载了所有的算数运算符，使其能够用于valarray对象，
因此你可以这样做：
vad3 = vad1 + vad2;


要将数组中每个元素的值扩大2.5倍，STL方法如下：
transform(ved3.begin(), ved3.end(), ved3.begin(),
        bind1st(multiplies<double>(), 2.5));

valarray类重载了将valarray对象乘以一个值的运算符，
还重载了各种组合赋值运算符，
因此可以采取下列两种方法之一：
vad3 = 2.5 * vad3;
vad3 *= 2.5;


假设你要计算数组中每个元素的自然对数，并将计算结果存储到另一个数组的
相应元素中，STL方法如下：
transform(ved1.begin(), ved1.end(), 
        ved3.begin(), log);

valarray类重载了这种数学函数，使之接受一个valarray参数，
并返回一个valarray对象，因此你可以这样做：
vad3 = log(vad1);

也可以使用 apply()方法，该方法也适用于非重载函数:
vad3 = vad1.apply(log);
方法apply()不修改调用对象，而是返回一个包含结果的新对象


C++提供了接受valarray对象作为参数的模板函数
begin()和end()
因此，你将使用begin(vad) 而不是 vad.begin
这些函数返回的值满足STL区间的需求：
sort(begin(vad), end(vad));


除前面讨论的外，valarray类还有很多其他特性。
例如，
如果numbers是一个valarray<double>对象，
则下面的语句将创建一个bool数组，
其中vbool[i]被设置为numbers[i] > 9的值，即true或false:
valarray<bool> vbool = numbers > 9;


----------------------------------------------------------------
还有扩展的下标指定版本，来看其中的一个：slice类
slice类对象可用作数组索引，这这种情况下，
它表的不是一个值而是一组值。
slice对象被初始化为三个整数值：起始索引、索引数和跨距。

起始索引是第一个被选中的元素的索引，
索引数指出要选择多少个元素
跨距表示元素之间的间隔

例如，
slice(1, 4, 3) 创建的对象表示选择4个元素，
它们的索引分别是 1， 4， 7 和 10.

如果varint是一个valarray<int>对象，
则下面的语句将把第1、4、7、10个元素都设置为10：
varint[slice(1, 4, 3)] = 10;


----------------------------------------------------------------
模板initializer_list是新增的。
你可使用初始化列表语法将STL容器初始化为一系列值：

std::vector<double> payments {45.99, 39.23, 19.95, 89.01};
这将创建一个包含4个元素的容器，并使用列表中的4个值来初始化这些元素
这之所以可行，
是因为容器类现在包含将initializer_list<T>作为参数的构造函数。


通常，考虑到C++11 新增的通用初始化语法，可使用表达式{}
而不是()来调用类构造函数：
shared_ptr<double> pd {new double};


但如果类也有接受initializer_list作为参数的构造函数，
这将带来问题：
std::vector<int> vi{10};
这将调用哪个构造函数呢？
std::vector<int> vi(10);    // case A: 10 uninitialized elements
std::vector<int> vi({10});  // case B: 1 element set to 10
答案是：
如果类有接受initializer_list作为参数的构造函数，
则使用语法{}将调用该构造函数，
因此在这个示例中，对应的是情形B
----------------------------------------------------------------
所有initializer_list元素的类型都必须相同，
但编译器将进行必要的转换：
std::vector<double> payments {45.99, 39.23, 19, 89};
在这里，由于vector的元素类型为double，
因此列表的类型为initializer_list<double>，所以19和89被转换为double

但不能进行隐式的窄化转换：
std::vector<int> values = {10, 8, 5.5}; // narrowing, compile-time error

在这里，元素类型为int，不能隐式地将5.5转换为 int


----------------------------------------------------------------
C++提供了一组功能强大的库，这些库提供了很多编程问题的解决方案以及
简化其他问题的工具。

string类为将字符串作为对象来处理提供了一种方便的方法。
string类提供了自动内存管理功能以及众多处理字符串的方法和函数

诸如auto_ptr以及C++新增的shared_ptr 和 unique_ptr 等智能指针模板
使得管理由new分配的内存更容易。如果使用这些智能指针(而不是常规指针)
来保存new返回的地址，则不必在以后使用删除运算符。
智能指针对象过期时，其析构函数将自动调用delete运算符。


STL是一个容器类模板、迭代器模板、函数对象模板和算法函数模板的集合，
它们的设计是一致的，都是基于泛型编程原则的。算法通过使用模板，从而
独立于所存储的对象的类型；通过使用迭代器接口，从而独立于容器的类型。
迭代器是广义指针。

STL使用术语“概念”来描述一组要求。
例如，
正向迭代器的概念包含这样的要求，即正向迭代器能够被解除引用，以便读写，
同时能够被递增。
概念真正的实现方式被称为概念的“模型”。
例如，
正向迭代器概念可以是常规指针或导航链表的对象。
基于其他概念的概念叫做“改进”。
例如，
双向迭代器是正向迭代器概念的改进。


诸如vector 和 set等容器类是容器概念(如容器、序列和关联模型)的模型。
STL定义了多种容器类模板：vector, deque, list, set, multiset, map,
multimap和 bitset; 还定义了适配类模板 queue, priority_queue和stack;
这些类让底层容器类能够提供适配器类模板名称所建议的特性接口。
因此，stack虽然在默认情况下是基于vector的，但仍只允许在栈顶进行插入和删除。
C++新增了forward_list, unordered_set, unordered_multiset, unordered_map和
unordered_multimap.


有些算法被表示为容器类方法，但大量算法都被表示为通用的、非成员函数，
这是通过将迭代器作为容器和算法之间的接口得以实现的。
这种方法的一个优点是：
只需一个诸如 for_each() 或 copy() 这样的函数，
而不必为每种容器提供一个版本；
另一个优点是：
STL算法可用于非STL容器，如常规数组、string对象、
array对象以及你设计的秉承STL迭代器和容器规则的任何类。


容器和算法都是由其提供或需要的迭代器类型表征的。
应当检查容器是否具备支持算法要求的迭代器概念。
例如，
for_each() 算法使用一个输入迭代器，所有的STL容器类类型
都满足其最低要求
而 sort() 则要求随机访问迭代器，并非所有的容器类都支持
这种迭代器。
如果容器类不能满足特定算法的要求，则可能提供一个专用的办法。


STL还提供了函数对象(函数符)，函数对象是重载了 ()运算符，
即定义了 operator()() 方法的类。可以使用函数表示法来调用
这种类的对象，同时可以携带额外的信息。
自适应函数符有 typedef语句，这种语句标识了函数符的参数类型
和返回类型。这些信息可供其他组件(如函数适配器)使用。


通过表示常用的容器类型，并提供各种使用高效算法实现的常用操作，
STL提供了一个非常好的可重用代码源。可以直接使用STL工具来解决
编程问题，也可以把它们作为基本部件，来构建所需的解决方案。


模板类complex 和 valarray 支持复数和数组的数值运算。








