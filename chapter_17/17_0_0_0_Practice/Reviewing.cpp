//Copyright (c) 2022 user1687569

#include <iostream>

输入、输出和文件

用于文件输入和输出的C++工具都是基于cin 和 cout所基于的基本类定义

----------------------------------------------------------
17.1.1 流和缓冲区
C++程序把输入和输出看作字节流。
输入时，程序从输入流中抽取字节；
输出时，程序将字节插入到输出流中


C++程序通常在用户按下回车键时刷新输入缓冲区。
这是为什么本书的例子没有一开始就处理输入，
而是等到用户按下回车键后再处理的原因。
对于屏幕输出，C++程序通常在用户发送换行符时刷新输出缓冲区。
程序也可能会在其他情况下刷新输入，例如输入即将到来时，
这取决于实现。
C++程序只检查字节流，而不需要知道字节来自何方
同理，通过使用流，C++程序处理输出的方式将独立于其去向。
因此管理输入包含两步：
1. 将流与输入去向的程序关联起来
2. 将流与文件连接起来

刷新缓冲区 flushing the buffer

----------------------------------------------------------
17.1.2 流、缓冲区和iostream文件
ios类：一般流属性，包括一个指向streambuf对象的指针
streambuf类：管理输入、输出缓冲区的内存
ostream类：输出方法
istream类：输入方法
iostream类：从istream 和 ostream 类继承了输入和输出方法

streambuf类为缓冲区提供了内存，并提供了用于填充缓冲区、
访问缓冲区内容、刷新缓冲区和管理缓冲区内存的类方法；

----------------------------------------------------------
在程序中包含iostream文件将自动创建8个流对象，
4个用于窄字符流，4个用于宽字符流

cin对象对应于标准输入流
cout对象与标准输出流相对应
cerr对象与标准错误流相对应，可用于显示错误消息。默认情况下，这个流被关联到
    标准输出设备。这个流没有被缓冲。
clog对象也对应着标准错误流。在默认情况下，这个流被关联到标准输出设备，通常
    是显示器。这个流被缓冲。

----------------------------------------------------------
17.1.3重定向
输入重定向 <
输出重定向 >

cout 与 标准错误流(cerr, clog)之间的区别？
答：默认情况下，这3个对象都被发送给显示器。
但对标准输出重定向 并不会影响 cerr 或 clog,
即使常规的cout输出被重定向到其他地方。

----------------------------------------------------------
17.2 使用cout进行输出
C++将输出看作字节流(根据实现和平台的不同，可能是8位、16位或32位
的字节，但都是字节)，但在程序中，很多数据被组织成比字节更大的单位。

ostream类最重要的任务之一是将数值类型(如int或float)转换为以文本形式
表示的字符流。也就是说，ostream类将数据内部表示(二进制位模式)转换
为由字符字节组成的输出流。


----------------------------------------------------------
17.2.1 重载的<<运算符
ostream类重新定义了 <<运算符，方法是将其重载为输出
在这种情况下， << 叫作插入运算符，而不是左移运算符
插入运算符被重载，使之能够识别C++中所有的基本类型：
#include <iostream>

1. 输出与指针
C++用指向字符串存储位置的指针来表示字符串
指针的形式可以是char数组名、显式的char指针或用引号括起的字符串

2. 拼接输出
插入运算符的所有化身的返回类型都是 ostream &

17.2.2 其他ostream方法
除了各种 operator<<()函数外，
ostream类还提供了put()方法和 write()方法
前者用于显示字符，后者用于显示字符串
cout.put('W');
basic_ostream<charT, traits>& write(const char_type * s, streamsize n);
write()的第一个参数提供了要显示的字符串的地址，
第二个参数指出要显示多少个字符串。

write()方法并不会在遇到空字符时自动停止打印字符，
而只是打印特定数目的字符，即使超出了字符串的边界！

----------------------------------------------------------
17.2.3 刷新输出缓冲区

通常，缓冲区为512字节或其整数倍。

对于屏幕输出来说，首先填充换种去的重要性要低得多。
如果必须重述消息 "Press any key to continue"以便使用512个字节来填充
缓冲区，实在是太不方便了。
所幸的是，在屏幕输出时，程序不必等到缓冲区被填满。
例如，
将换行符发送到缓冲区后，将刷新缓冲区。
多数C++实现都会在输入即将发生时刷新缓冲区
也就是说，假设有下面的代码：
cout << "Enter a number: ";
float num;
cin >> num;


程序期待输入这一事实，将导致它立刻显式cout消息，
(即刷新 "Enter a number:" 消息)，即使输出字符串中
没有换行符。如果没有这种特性，程序将等待输入，
而无法通过cout消息来提示用户。

如果实现不能在所希望时刷新输出，可以使用两个控制符中的
一个来强行进行刷新。
控制符flush刷新缓冲区，
而控制符endl刷新缓冲区，并插入一个换行符。

事实上，控制符也是函数。
例如，可以直接调用flush()来刷新cout缓冲区：
flush(cout);

然而， ostream类对<<插入运算符进行了重载，使得下述表达式
将被替换为函数调用 flush(cout):
cout << flush;

----------------------------------------------------------
17.2.4 用cout进行格式化

1. 修改显示时使用的计数系统
ostream -> ios -> ios_base
ios_base类存储了描述格式状态的信息

要控制整数以十进制、十六进制还是八进制显示，
可以使用dec、hex和oct控制符。
下面的函数调用将cout对象的计数系统格式状态设置为十六进制：
hex(cout);

虽然控制符实际上是函数，但它们通常的使用方式为：
cout << hex;

----------------------------------------------------------
2. 调整字段宽度
width()方法只影响将显示的下一个项目，然后字段宽度将恢复为默认值。

C++永远不会截短数据，
因此如果试图在宽度为2的字段中打印一个7位值，
C++将增宽字段，以容纳该数据。
C/C++的原则是：显示所有的数据比保持列的整洁更重要。


3. 填充字符
填充字符：
在默认情况下，cout用空格填充字段中未被使用的部分
可以用fill()成员函数来改变填充字符。
例如，
下面的函数调用填充字符改为星号：
cout.fill('*');


4. 设置浮点数的显示精度
C++的默认精度为 6 位(但末尾的0将不显示)
precision()成员函数使得能够选择其他值
例如，
下面的语句将cout的精度设置为2：
cout.precision(2);

和width()的情况不同，但与fill()类似，
新的精度设置将一直有效，直到被重新设置

5. 打印末尾的0和小数点
对于有些输出（如价格或栏中的数字），保留末尾的0将更为美观。
$20.40 比 $20.4 更美观。
iostream系列类没有提供专门用于完成这项任务的函数，
但ios_base类提供了一个setf()函数，能够控制多种格式化特性。
这个类还定义了多个常量，可用作该函数的参数。
例如，
下面的函数调用使cout显示末尾小数点：
std::cout.setf(std::ios_base::showpoint);


----------------------------------------------------------
6. 再谈setf()

setf()函数有两个原型：
第一个为：
fmtflags setf(fmtflags);
其中，fmtflags是bitmask类型的typedef名，用于存储格式标记，
并返回以前的设置


第二个为：
setf()原型接受两个参数，并返回以前的设置：
fmtflags setf(fmtflags, fmtflags);

函数的这种重载格式用于设置由多位控制的格式选项。
第一个参数和以前一样，也是一个包含了所需设置的fmtflags值
第二个参数指出要清除第一个参数中的哪些位
下面的函数调用与使用十六进制控制符的作用相同：
std::cout.setf(std::ios_base::hex, std::ios_base::basefield);
----------------------------------------------------------
第二个参数             |  第一个参数        |      含义
----------------------------------------------------------
ios_base::basefield   | ios_base::dec     |  使用基数10
                      | ios_base::oct     |  使用基数8
                      | ios_base::hex     |  使用基数16
----------------------------------------------------------
ios_base::floatfield  | ios_base::fixed   |   使用定点计数法
                      | ios_base::scientific | 使用科学计数法 
----------------------------------------------------------
ios_base::adjustedfield | ios_base::left  |  使用左对齐
                        ios_base::right   |  使用右对齐
                        ios_base::internal|  符号或技术前缀左对齐，值友对齐
----------------------------------------------------------               

setf()函数是ios_base类的一个成员函数。
由于这个类是ostream类的基类，因此可以使用cout对象来调用该函数
例如，
要左对齐，可使用下面的调用：
ios_base::fmtflags old = std::cout.setf(std::ios::left, std::ios::adjustfield);
要恢复以前的设置，可以这样做：
std::cout.setf(old, std::ios::adjustfield);

----------------------------------------------------------
调用setf()的效果可以通过unsetf()消除，
后者的原型如下：
void unsetf(fmtflags mask);

----------------------------------------------------------
7. 标准控制符
使用setf()不是进行格式化的、对用户最为友好的方式，
C++提供了多个控制符，能够调用setf()，并自动提供正确的参数。
前面已经介绍过 dec, hex 和 oct
例如，
下面的语句打开左对齐和定点选项：
std::cout << left << fixed;

一些标准控制符：
boolalpha
noboolalpha
showbase
noshowbase
showpoint
noshowpoint
showpos
noshowpos
uppercase
nouppercase
internal
left
right
dec
hex
oct
fixed
scientific

----------------------------------------------------------
8. 头文件 iomanip
使用iostream工具来设置一些格式值不太方便，
为简化工作，C++在头文件iomanip中提供了其他一些控制符，
它们能够提供前面讨论过的服务。
3个最常用的控制符分别是：
setprecision()
setfill()
setw()
这3个控制符带参数

setprecision()控制符接受一个指定精度的整数参数
setfill()控制符接受一个指定填充字符的char参数
setw()控制符接受一个指定字段宽度的整数参数

std::cout << 's' << setw(8) << 'a' << std::endl;
setw()只对其后面紧跟的输出产生作用，如上例中，
表示'a'共占8个位置，不足的7个位置用空格填充。

setw() 可与 setfill() 配合使用：
cout << setfill('*') << setw(5) << 'a' << std::endl;
则输出： ****a


----------------------------------------------------------
17.3 使用cin进行输入
cin对象将从输入流中抽取字符，抽取还涉及类型转换。
cin对象根据接收值得变量的类型，使用其方法将字符序列转换为所需的类型

通常，可以这样使用cin：
cin >> value_holder;

其中，value_holder 为存储输入的内存单元，
它可以是变量、引用、被解除引用的指针，
也可以是类或结构的成员

cin解释输入的方式取决于value_holder的数据类型
istream类重载了抽取运算符 >>, 使之能够识别下面这些基本类型：
signed char &
unsigned char &
char &
short &
unsigned short &
int &
unsigned int &
long &
unsigned long &
long long & (C++11)
unsigned long long & (C++11)
float &
double &
long double &

典型的运算符函数的原型如下：
istream & operator>>(int &);

参数和返回值都是引用。
----------------------------------------------------------
117.3.1 cin>>如何检查输入

不同版本的抽取运算符查看输入流的方法使相同的，
它们跳过空白(空格、换行符和制表符)，直到遇到非空白符
即使对于单字符模式(参数类型为char、unsigned char 或signed char)
情况也是如此

在单字符模式下，>>运算符将读取该字符，将它放置到指定的位置
在其他模式下， >>运算符将读取一个指定类型的数据
也就是说，它读取从非空白字符开始，
到与目标类型不匹配的第一个字符之间的全部内容

----------------------------------------------------------
#include <iostream>

17.3.2 流状态
cin或cout对象包含一个描述流状态(stream state)的数据成员
(从ios_base类那里继承的)。
流状态(被定义为 iostate 类型，而iostate是一种bitmask类型)
由3个ios_base元素组成：eofbit、badbit或failbit,
其中每个元素都是一位，可以是1(设置)或0(清除)
当cin操作到达文件末尾时，它将设置eofbit;
当cin操作未能读取到预期的字符时，它将设置failbit

----------------------------------------------------------
成员                 描述
----------------------------------------------------------
eofbit            如果到达文件尾，则设置为1
badbit            如果流被破坏，则设置为1；例如，文件读取错误
failbit           如果输入操作未能读取预期的字符或输出操作没有写入预期的字符，
                  则设置为1
goodbit           另一种表示0的方法
good()
eof()
bad()
fail()
rdstate()
exceptions()
exceptions(isostate ex)
clear(iostate s)
setstate(iostate s)

1. 设置状态
clear() 和 setstate()很相似
它们都重置状态，但采取的方式不同
clear()方法将状态设置为它的参数

因此，
下面的调用将使用默认参数0，
这将清楚全部3个状态位 (eofbit, badbit 和 failbit)
clear();

同样，
下面的调用将状态设置为eofbit;
也就是说，eofbit将被设置，另外两个状态位被清除
clear(eofbit);

而setstate()方法只影响其参数中已设置的位
因此，下面的调用将设置eofbit，而不会影响其他位：
std::setstate(eofbit);

为什么要重新设置流状态呢？
对于程序员来说，最常见的理由是，
在输入不匹配或到达文件尾时，需要使用不带参数的clear()重新打开输入。
这样做是否有意义，取决于程序要执行的任务。


2. I/O和异常
假设某个输入函数设置了eofbit，这是否会导致异常被引发呢？
在默认情况下，答案是否定的。
但可以使用 exceptions()方法来控制异常如何被处理。


3. 流状态的影响
只有在流状态良好(所有的位都被清除)的情况下，下面的测试才返回true:
while(cin >> input)


设置流状态位有一个非常重要的后果：流将对后面的输入或输出关闭，
直到位被清除。

如果希望程序在流状态位被设置后能够读取后面的输入，就必须将流状态
重置为良好。这可以通过调用clear()方法来实现

注意，这还不足以重新设置流状态。
导致输入循环终止的不匹配输入仍留在输入队列中，程序必须跳过它。

一种方法是一直读取字符，直到到达空白为止。
isspace()函数是一个cctype函数，它在参数是空白字符时返回true.
另一种方法是，丢弃行中的剩余部分，而不仅仅是下一个单词：
while(std::cin.get() != '\n')
    continue;

----------------------------------------------------------
17.3.3 其他istream类方法
方法 get(char &) 和 get(void) 提供不跳过空白的单字符输入功能
函数get(char *, int, char) 和 getline(char *, int, char)在默认情况下读取整行而不是一个单词
它们被称为非格式化输入，因为它们只是读取字符输入，
而不会跳过空白，也不进行数据转换


----------------------------------------------------------
3. 字符串输入
getline()、get() 和 ignore()


istream & get(char *, int, char);
istream & get(char *, int);
istream & getline(char *, int, char);
istream & getline(char *, int);
第一个参数是用于放置输入字符串的内存单元的地址
第二个参数比要读取的最大字符数大1
第三个参数指定用作分界符的字符


get() 和 getline()之间的主要区别在于，
get()将换行符留在输入流中，这样接下来的输入操作首先看到的将是换行符，
而 getline()抽取并丢弃输入流中的换行符

ignore()成员函数：
该函数接受两个参数：
一个是数字，指定要读取的最大字符数
另一个是字符，用作输入分界符
例如，
下面的函数调用读取并丢弃接下来的255个字符或直到到达第一个换行符：
std::cin.ignore(255, '\n');


----------------------------------------------------------
17.3.4 其他istream方法
其他istream方法包括
read()

char gross[144];
std.cin.read(gross, 144);
与getline() 和 get() 不同的是，
read()不会在输入后加上空值字符，
因此不能将它转换为字符串。
read()方法不是专为键盘输入设计的，
它最常与 ostream write()函数结合使用，
来完成文件输入和输出。
因此，可以像下面这样拼接起来。
char gross[144];
char score[20];
std::cin.read(gross, 144).read(score, 20);


peek()
查看下一个字符,但不抽取输入流中的字符。

gcount() 返回最后一个非格式化抽取方法读取的字符数。
这意味着字符是由get(), getline(), ignore() 或read()方法读取的，
而不是由抽取运算符(>>)读取的

putback()
将一个字符插入到输入字符中，
被插入的字符将是下一条输入语句读取的第一个字符


----------------------------------------------------------
17.4 文件输入和输出
C++在头文件fstream中定义了多个新类，其中包括
用于文件输入的ifstream类和
用于文件输出的ofstream类。

C++还定义了一个fstream类，用于同步文件 I/O

声明一个ofstream对象，
ofstream fout;
然后使用open()方法， fout.open("jat.txt");

也可以使用另一个构造函数将这两条语句合并成一条语句：
ofstrem fout("jar.txt");


警告：以默认模式打开文件进行输出将自动把文件的长度截短为零，
这相当于删除已有的内容。

输入和输出一样，也是被缓冲的，因此创建 ifstream对象与fin一样，
将创建一个由 fin对象管理的输入缓冲区。
与输出一样，通过缓冲，传输数据的速度比逐字节传输要快得多

当输入和输出流对象过期时，到文件的连接将自动关闭。
另外，也可以使用close()方法来显式地关闭到文件的连接：
fout.close()
fin.close()


关闭这样的链接并不会删除流，而只是断开流到文件的连接
然而，流管理装置仍被保留。
例如，fin对象与它管理的输入缓冲区仍然存在。
可以将流重新连接到用一个文件或另一个文件

程序将该文件名读取到一个string对象中，然后使用c_str()
来给ofstream和ifstream的构造函数提供一个C-风格字符串参数。

----------------------------------------------------------
17.4.2 流状态检查和is_open()

以前，检查文件是否成功打开的常见方式如下：
if(fin.fail())
if(!fin.good())
if(!fin)

较新的C++实现提供了一种更好的检查文件是否被打开的方法  is_open()方法
if(!fin.is_open())
{
}

----------------------------------------------------------
17.4.3 打开多个文件

程序可能需要打开多个文件。
打开多个文件的策略取决于它们将被如何使用。
如果需要同时打开两个文件，则必须为每个文件创建一个流。
例如，将两个排序后的文件拼接成第三个文件的程序，
需要为两个输入文件创建两个ifstream对象，
并为输出文件创建一个 ofstream对象。
可以同时打开的文件数取决于操作系统。

然而，可能要依次处理一组文件。
例如，可能要计算某个名称在10个文件中出现的次数。
在这种情况下，可以打开一个流，并将它依次关联到各个文件。
使用这种方法，首先需要声明一个ifstream对象，然后使用
open()方法将这个流与文件关联起来。


----------------------------------------------------------
17.4.4 命令行处理技术
文件处理程序通常使用命令行参数来指定文件。
命令行参数是用户在输入命令时，在命令行中输入的参数。

C++由一种让命令行环境中运行的程序能够访问命令行参数的机制，
方法是使用下面的main()函数：

int main(int argc, char *argv[]);
argc为命令行中的参数个数，其中包括命令名本身

argv变量为一个指针，它指向一个指向char的指针。
这过于抽象，但可以将argv看作一个指针数组，其中的
指针指向命令行参数，argv[0]是一个指针，指向存储
第一个命令行参数的字符串的第一个字符，依次类推。
也就是说，argv[0]是命令行中的第一个字符串。

例如，
假设有下面的命令行：
wc report1 report2 report3
则argc为4，argv[0]为wc，argv[1]为report1,以此类推。


----------------------------------------------------------
文件模式
文件模式描述的是文件将被如何使用：读、写、追加等
将流与文件关联时，都可以提供指定文件模式的第二个参数：

ios_base类定义了一个openmode类型，用于表示模式；
ios_base::in
ios_base::out
ios_base::ate
ios_base::app
ios_base::trunc
ios_base::binary

ifstream open()方法和构造函数用 ios_base::in (打开文件以读取)作为模式参数的默认值
ofstream open()方法和构造函数用 ios_base::out| ios_base::trunc (打开文件，以读取并截短文件)作为默认值


如果不希望打开文件时将其内容删除，C++提供了其他的选择。
例如，
如果要保留文件内容，并在文件尾添加新信息，则可以使用 ios_base::app模式
ofstream fout("bagels", ios_base::out | ios_base::app);


----------------------------------------------------------
2. 二进制文件

以文本格式存储值 -2.324216e+07时，将存储该数字包含的13个字符，
这需要将浮点数的计算机内部表示转换为字符格式，这正是 <<插入运算符
完成的工作

另一方面，二进制格式指的是存储值的计算机内部表示

来看一个更具体的例子：
const int LIM = 20;
struct planet
{
    char name[LIM];
    double population;
    double g;
};
planet pl;

要将结构pl的内容以文本格式保存，可以这样做：
ofstream fout("planets.dat", ios_base::out | ios_base::app);
fout << pl.name << " " << pl.population << " " << pl.g << "\n";

要用二进制格式存储相同的信息，可以这样做：
ofstream fout("planets.dat",
            ios_base::out | ios_base::app | ios_base::binary);
fout.write((char *)&pl, sizeof pl);

要使用文件恢复信息，请通过一个ifstream对象使用相应的read()方法：
ifstream fin("planets.dat", ios_base::in | ios_base::binary);
fin.read((char *) &pl, sizeof pl);


----------------------------------------------------------
17.4.6 随机存取
随机存取指的是直接移动(不是依次移动)到文件的任何位置。
随机存取常被用于数据库文件，程序维护一个独立的索引文件，
该文件指出数据在主数据文件中的位置。
这样，程序便可以直接跳到这个位置，读取(还可能修改)其中的数据。


追加模式只允许程序将数据添加到文件尾，文件的其他部分是只读的；
也就是说，可以读取原始数据，但不能修改它；
要修改数据，必须使用 ios_base::out.
同时使用in模式和out模式将得到读/写模式，因此只需添加二进制元素即可。

finout.open(file, ios_base::in | ios_base::out | ios_base::binary);

接下来，需要一种在文件中移动的方式。
fstream类为此继承了两个方式：
seekg()
seekp()
前者将输入指针移到指定的文件位置
后者将输出指针移到指定的文件位置

也可以将seekg()用于ifstream对象，
将seekp()用于ofstream对象。

下面是seekg()的原型：
basic_istream<charT, traits>& seekg(off_type, ios_base::seekdir);
basic_istream<charT, traits>& seekg(pos_type);


本章将使用char类型的模板具体化。
对于char具体化，上面两个原型等同于下面的代码：
istream & seekg(streamoff, ios_base::seekdir);
istream & seekg(streampos);


seek_dir参数是ios_base类中定义的另一种整型，有3个可能的值
常量ios_base::beg指相对于文件开始处的偏移量
常量ios_base::cur指相对于当前位置的偏移量
常量ios_base::end指相对于文件尾的偏移量

streampos值表示文件中的绝对位置(从文件开始处算起)

如果要检查文件指针的当前位置，则对于输入流，可以使用tellg()方法，
对于输出流，可以使用tellp()方法。
它们都返回一个表示当前位置的streampos值(以字节为单位，从文件开始处算起)


----------------------------------------------------------
tmpnam()函数创建一个临时文件名
char * tmpnam(char* pszName);


----------------------------------------------------------
17.5 内核格式化
iostream族(family)支持程序与终端之间的I/O，
而fstream族使用相同的接口提供程序和文件之间的I/O.
C++库还提供了sstream族，它们使用相同的接口提供程序和string对象之间的I/O.

读取string对象中的格式化信息或将格式化信息写入string
对象中被称为 内核格式化 incore formatting

头文件sstream定义了一个从ostream类派生而来的 ostringstream类，
还有一个基于wostream的wostringstream类，这个类用于宽字符集。

istringstream类允许使用istream方法族读取istringstream对象中的数据，
istringstream对象可以使用string对象进行初始化





