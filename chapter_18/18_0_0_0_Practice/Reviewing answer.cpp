//Copyright (c) 2022 user1687569

// 1
std::vector<int> ai{3, 9, 4, 7, 1};


// 2
r2(w+1);        不合法，w+1是右值
r2(up(w));      不合法，up(w)是右值
r3(w);          不合法，w是左值

// 3.a
double & rx         非const左值引用与左值实参匹配
const double & rx   w+1为右值，const左值引用可指向它们的拷贝
const double & rx   up(w)为右值，const左值引用可指向它们的拷贝
// 3.b
double & rx         左值引用与左值实参w匹配
double && rx        右值引用与右值实参匹配
double && rx        右值引用与右值实参匹配
// 3.c
const double & rx   左值引用与左值实参w匹配
double && rx        右值引用与右值实参匹配
double && rx        右值引用与右值实参匹配

//4 
哪些成员函数是特殊的成员函数？它们特殊的原因是什么？
答：
默认构造函数、复制构造函数、复制赋值运算符、析构函数
移动构造函数和移动赋值运算符。
这些函数之所以特殊，是因为编译器将根据情况自动提供它们的默认版本


// 5
class Fizzle
{
private:
    double bubbles[4000];
    ...
};
为什么不适合给这个类定义移动构造函数？
要让这个类适合定义移动构造函数，应如何修改存储4000个double值的方式？
答：在转让数据所有权(而不是复制数据)时，可使用移动构造函数，
但对于标准数组，没有转让其所有权的机制。
如果Fizzle使用指针和动态内存分配，则可将数据的地址赋给新指针，
以转让其所有权。


// 6
show2(18.0, [](double x) { return 1.8 * x + 32; });
